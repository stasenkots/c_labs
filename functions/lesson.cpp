//
// Created by kotozavrina on 04/11/2021.
//

//
// Created by kotozavrina on 19/10/2021.
//

#include "iostream"


void boo(int &)

void print(int);


int print(int num) {
    std::cout << num << std::endl
    return
}


//Объявление vs. Определение
//Параметры vs. Аргументы


//

//4. Порядок, в котором инициализируются параметры в круглых скобках функции,
//определяет каждый компилятор отдельно, так как С++ явно не указывает этот порядок обработки.
//С параметрами-переменными это не столь важно и критично, но если вы будете использовать в качестве параметров
//функции вызовы других функций (что является плохой практикой и не рекомендуется к использованию),
//то результат может быть неожиданным.


//Передача по значению
//Плюсы передачи по значению:
//
//Аргументы никогда не изменяются функцией, в которую передаются, что предотвращает возникновение побочных эффектов.
//
//Минусы передачи по значению:
//
//Копирование структур и классов может привести к значительному снижению производительности (особенно, когда функция вызывается много раз).


int main() {

    x = 1;
    y = 1
    boo(x)
    student
    100
    mb

}
//x = 1
//
//boo(x)    1 - 0x2933123
//            3 - 0x1232132
//x= 1 copy y = 1  x,y indepdenent

void boo(int y) {
    std::cout << "y = " << y << std::endl;
}

//Передача по ссылке

//Плюсы передачи по ссылке:
//
//Ссылки позволяют функции изменять значение аргумента,
// что иногда полезно.
// В противном случае, для гарантии того, что функция не изменит значение аргумента, нужно использовать константные ссылки.
//
//Поскольку при передаче по ссылке копирования аргументов не происходит,
// то этот способ гораздо эффективнее и быстрее передачи по значению, особенно при работе с большими структурами или классами.
//
//Ссылки могут использоваться для возврата сразу нескольких значений из функции (через параметры вывода).
//
//Минусы передачи по ссылке:
//
//Трудно определить, является ли параметр, переданный по неконстантной ссылке,
// параметром ввода, вывода или того и другого одновременно. Разумное использование const и суффикса Out для внешних переменных решает эту проблему.
//
//По вызову функции невозможно определить, будет аргумент изменен функцией или нет.
// Аргумент, переданный по значению или по ссылке, выглядит одинаково.
// Мы можем определить способ передачи аргумента только просмотрев объявление функции.
// Это может привести к ситуации, когда программист не сразу поймет, что функция изменяет значение аргумента.


x,
value dependent
x->
value x
-1- 0x213123
value - 1 - 0x213123

int main() {

    x = 1;
    y = boo(x,x++)
    student
    sin = sin(x, y)

    //x = 7

}

x = -21312324 0x213213;
x_temp = -21312341 - 0x213213


int getXY(int &p) { // int& p = x;


    x  = 1;
    y = 2;
    return x
}


//Возврат значений по ссылке,по


//Передача по адресу


#include <iostream>


//x -> 0xFFF11 -> 1
//y -> 0xGG1123 -> 2

//const int*
/
void boo(int* ptr)  // &x ,ptr = &x,
{
    *ptr = 7;
}

int main()
{
    int value = 4;

    std::cout << "value = " << value << '\n';  // 4
    boo(&value);
    std::cout << "value = " << value << '\n'; // 7
    return 0;
}

//Плюсы передачи по адресу:
//
//Передача по адресу позволяет функции изменить значение аргумента, что иногда полезно.
// В противном случае, используем const для гарантии того, что функция не изменит аргумент.
//
//Поскольку копирования аргументов не происходит, то скорость передачи по адресу достаточно высокая,
// даже если передавать большие структуры или классы.

