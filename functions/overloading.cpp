//
// Created by kotozavrina on 16/11/2021.
//
#include "iostream"


int subtract(int a, int b, int c) {
    return a - b - c;
}


int subtract(int a, int b)
{
    return a - b;
}

double subtract(double a, double b)
{
    return a - b;
}

int main(){

    subtract(1,2)
    subtract(1.3,1.3)
    subtract(1,1,2)


}

// Тип возврата значение не иммет

//
//Выполнение вызова перегруженной функции приводит к одному из трех возможных результатов:
//
//Совпадение найдено. Вызов разрешен для соответствующей перегруженной функции.
//
//Совпадение не найдено. Аргументы не соответствуют любой из перегруженных функций.
//
//Найдены несколько совпадений. Аргументы соответствуют более чем одной перегруженной функции.


//Шаг №1: C++ пытается найти точное совпадение.
// Это тот случай, когда фактический аргумент точно соответствует типу параметра одной из перегруженных функций.

//Шаг №2: Если точного совпадения не найдено, то C++ пытается найти совпадение путем дальнейшего неявного преобразования типов.

//Шаг №3: Если неявное преобразование невозможно, то C++ пытается найти соответствие посредством стандартного преобразования. В стандартном преобразовании:
//
//   Любой числовой тип будет соответствовать любому другому числовому типу, включая unsigned (например, int равно float).
//
//   enum соответствует формальному типу числового типа данных (например, enum равно float).
//
//   Ноль соответствует типу указателя и числовому типу (например, 0 как char * или 0 как float).
//
//   Указатель соответствует указателю типа void.


//неоднозначное совпадение


//неоднозначное совпадение


void print(unsigned int value);
void print(float value);

print('b');
print(0);
print(3.14159);


//Решение №1: Просто определить новую перегруженную функцию,
// которая принимает параметры именно того типа данных, который вы используете в вызове функции. Тогда C++ сможет найти точное совпадение.

//Решение №2: Явно преобразовать с помощью операторов явного преобразования неоднозначный параметр(ы) в соответствии с типом функции,
//которую вы хотите вызвать. Например, чтобы вызов print(0) соответствовал print(unsigned int), вам нужно сделать следующее:
